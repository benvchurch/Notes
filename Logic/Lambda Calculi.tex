\documentclass[12pt]{article}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}

\usepackage{import}
\import{"../Algebraic Geometry/"}{AlgGeoCommands}

\begin{document}
\author{Benjamin Church}
\title{\Huge $\lambda$-Calculi}

\section{Introduction}

\renewcommand{\red}{\triangleright}
\newcommand{\aconv}{\equiv_{\alpha}}
\newcommand{\bredo}{\red_{\beta,1}}
\newcommand{\bred}{\red_{\beta}}
\newcommand{\etared}{\red_{\eta}}
\newcommand{\etaredo}{\red_{\eta,1}}
\newcommand{\bered}{\red_{\beta\eta}}
\newcommand{\beredo}{\red_{\beta\eta,1}}

The $\lambda$-calculus (here we first introduce pure untyped $\lambda$-calculus) is a formal system designed to capture of the notions of ``function'' and ``composition''.

\begin{rmk}
A $\lambda$-expression will be a finite string made from the symbols $\lambda$, $.$, and an infinite list of variable symbols $x, y, z, \cdots$ or $a,b,c, \cdots$ or $x_1, x_2, x_3, \dots$ whatever you want to call them. We think of $\lambda x . M$ as the function that takes in $x$ and returns $M$ where $M$ is an expression possibly involving $x$. 
\end{rmk} 

\begin{defn}
A \textit{well-formed} $\lambda$-expression is defined recursively via,
\begin{enumerate}
\item any variable is a $\lambda$-expression
\item if $M$ is a $\lambda$-expression then $\lambda x . M$ is a $\lambda$-expression
\item if $M$ and $N$ are $\lambda$-expressions then $(M N)$ is a $\lambda$-expression.
\end{enumerate}
\end{defn}

\begin{rmk}
We have already said that we should interpret $\lambda x . M$ as a function. Then $(M, N)$ is an ``application'' of the function $M$ to $N$. We think of $((\lambda x . M) N)$ ``evaluating'' to $M[x := N]$ which is how this system captures the essence of functions and computation as evaluation though substitution. Although intutively we think of $\lambda$-expressions as functions, that actually take an input and produce a well-defined output, this is actually difficult to define because we will have to decide when a computation is ``finished'' and in fact computations may not halt complicating our desire to call these things functions. A major goal will be to somehow interpret these objects as honest-to-god functions. For now, we take a different perspective not that $\lambda$-expressions are ``machines'' but rather they are formal strings in a formal system. To create a formal system we need ``rules of inference'' which are conventionally called conversions and reductions.
\end{rmk}

\begin{defn}
REDUCTIONS AND COVERESIONS
\end{defn}

EXAMPLES

NORMAL EXPRESSIONS 

CHURCH-ROSSER 

UNIQUENESS OF NORMAL FORM

\begin{example}
A $\lambda$-expression need not admit a normal form. For example let,
\[ \omega = \lambda x . (x x) \]
this is the function that applies its input to itself. What happens if we apply $\omega$ to itsef then we get,
\[ \Omega = (\omega \omega) \]
and it is easy to see that,
\[ \Omega \bredo \Omega \]
and there are no other possible $\beta$-reductions. Therefore $\Omega$ does not have a $\beta$-normal form. We can think of it as corresponding to a computation that does not halt.
\end{example}

\section{Arithmetic and Logic in the $\lambda$-Calculus}

CHURCH ENCODING AND SIMPLE FUNCTIONS

\section{``Consistency'' of the $\lambda$-Calculus}

EARLY FORM INCONSISTENT

Look at section here https://plato.stanford.edu/entries/lambda-calculus/

and in Barendregt's book. 

THIS FORM IS CONSISTENT IN THE SENSE OF CANNOT DERIVE EVERYTHING

CURY'S PARADOX

\section{Recursion and Fixed Points}

\section{$\lambda$-Models}

\section{CORRECT NOTION OF LATTICES}

\section{Scott's Model $D_{\infty}$}

DEFINITION

SHOW THAT THE TWO FIXED POINT NOTIONS AGREE

\end{document}
